/* Generated By:JavaCC: Do not edit this line. SparqlParser.java */
package org.mulgara.sparql.parser;

import java.io.StringReader;
import static org.mulgara.sparql.parser.QueryType.*;
import org.mulgara.sparql.parser.cst.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.LinkedList;
import static org.mulgara.sparql.parser.cst.Nil.NIL_NODE;

public class SparqlParser implements SparqlParserConstants {

  private QueryStructureImpl queryStructure = new QueryStructureImpl();

  public void setDefaultBase(URI base) {
        queryStructure.setBase(base);
  }

  public static QueryStructure parse(String query) throws ParseException {
    SparqlParser parser = new SparqlParser(new StringReader(query));
    parser.Query();
    return parser.queryStructure;
  }

  public static QueryStructure parse(String query, URI defaultBase) throws ParseException {
    SparqlParser parser = new SparqlParser(new StringReader(query));
    parser.Query();
    parser.setDefaultBase(defaultBase);
    return parser.queryStructure;
  }

  private static String unquote(String s) {
    return s.substring(1, s.length() - 1);
  }

  private static String unTripleQuote(String s) {
    return s.substring(3, s.length() - 3);
  }

  private static GroupGraphPattern conjoin(GroupGraphPattern g1, GroupGraphPattern g2) {
        assert g2 != null;
    if (g1 == GroupGraphPattern.EMPTY) return g2;
    return new GraphPatternConjunction(g1, g2);
  }

  private static URI uri(String u) throws ParseException {
        try {
          return new URI(unquote(u));
        } catch (URISyntaxException e) {
          throw new ParseException("Bad URI syntax");
        }
  }

/* [1]      Query      ::=      Prologue ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery ) */
  final public void Query() throws ParseException {
    Prologue();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      SelectQuery();
      break;
    case CONSTRUCT:
      ConstructQuery();
      break;
    case DESCRIBE:
      DescribeQuery();
      break;
    case ASK:
      AskQuery();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
  }

/* [2]      Prologue      ::=      BaseDecl? PrefixDecl* */
  final public void Prologue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
      BaseDecl();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PREFIX:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      PrefixDecl();
    }
  }

/* [3]      BaseDecl      ::=      'BASE' IRI_REF */
  final public void BaseDecl() throws ParseException {
                    IRIReference ref;
    jj_consume_token(BASE);
    ref = IRIref();
                          queryStructure.setBase(ref.getUri());
  }

/* [4]      PrefixDecl      ::=      'PREFIX' PNAME_NS IRI_REF */
  final public void PrefixDecl() throws ParseException {
                      Token ns, ref;
    jj_consume_token(PREFIX);
    ns = jj_consume_token(PNAME_NS);
    ref = jj_consume_token(IRI_REF);
      queryStructure.addPrefix(ns.image, uri(ref.image));
  }

/* [5]      SelectQuery   ::=   'SELECT' ( 'DISTINCT' | 'REDUCED' )? ( Var+ | '*' ) DatasetClause* WhereClause SolutionModifier */
  final public void SelectQuery() throws ParseException {
                       Variable v;
    jj_consume_token(SELECT);
               queryStructure.setType(select);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
    case REDUCED:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                   queryStructure.setDistinct();
        break;
      case REDUCED:
        jj_consume_token(REDUCED);
                    queryStructure.setReduced();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      label_2:
      while (true) {
        v = Var();
                  queryStructure.addSelection(v);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR1:
        case VAR2:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
      }
      break;
    case 41:
      jj_consume_token(41);
            queryStructure.setSelectAll();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      DatasetClause();
    }
    WhereClause();
    SolutionModifier();
  }

/* [6]      ConstructQuery    ::=   'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier */
  final public void ConstructQuery() throws ParseException {
    jj_consume_token(CONSTRUCT);
                  queryStructure.setType(construct);
    ConstructTemplate();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      DatasetClause();
    }
    WhereClause();
    SolutionModifier();
  }

/* [7]      DescribeQuery      ::=      'DESCRIBE' ( VarOrIRIref+ | '*' ) DatasetClause* WhereClause? SolutionModifier */
  final public void DescribeQuery() throws ParseException {
                         Node n;
    jj_consume_token(DESCRIBE);
                 queryStructure.setType(describe);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case VAR1:
    case VAR2:
      label_5:
      while (true) {
        n = VarOrIRIref();
                          queryStructure.addSelection(n);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
      }
      break;
    case 41:
      jj_consume_token(41);
            queryStructure.setSelectAll();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_6;
      }
      DatasetClause();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
    case 44:
      WhereClause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    SolutionModifier();
  }

/* [8]      AskQuery      ::=   'ASK' DatasetClause* WhereClause */
  final public void AskQuery() throws ParseException {
    jj_consume_token(ASK);
            queryStructure.setType(ask);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_7;
      }
      DatasetClause();
    }
    WhereClause();
  }

/* [9]   DatasetClause   ::=   'FROM' ( DefaultGraphClause | NamedGraphClause ) */
  final public void DatasetClause() throws ParseException {
    jj_consume_token(FROM);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
      DefaultGraphClause();
      break;
    case NAMED:
      NamedGraphClause();
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* [10]    DefaultGraphClause    ::=    SourceSelector */
  final public void DefaultGraphClause() throws ParseException {
                              IRIReference ref;
    ref = SourceSelector();
                           queryStructure.addDefaultFrom(ref);
  }

/* [11]    NamedGraphClause    ::=    'NAMED' SourceSelector */
  final public void NamedGraphClause() throws ParseException {
                            IRIReference ref;
    jj_consume_token(NAMED);
    ref = SourceSelector();
                                   queryStructure.addNamedFrom(ref);
  }

/* [12]    SourceSelector    ::=    IRIref */
  final public IRIReference SourceSelector() throws ParseException {
                                  IRIReference r;
    r = IRIref();
                 {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

/* [13]    WhereClause    ::=    'WHERE'? GroupGraphPattern */
  final public void WhereClause() throws ParseException {
                       GroupGraphPattern g;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    g = GroupGraphPattern();
                                       queryStructure.setWhereClause(g);
  }

/* [14]    SolutionModifier    ::=    OrderClause? LimitOffsetClauses? */
  final public void SolutionModifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      OrderClause();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
    case OFFSET:
      LimitOffsetClauses();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
  }

/* [15]    LimitOffsetClauses    ::=    ( LimitClause OffsetClause? | OffsetClause LimitClause? ) */
  final public void LimitOffsetClauses() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
      LimitClause();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OFFSET:
        OffsetClause();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      break;
    case OFFSET:
      OffsetClause();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIMIT:
        LimitClause();
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* [16]    OrderClause    ::=    'ORDER' 'BY' OrderCondition+ */
  final public void OrderClause() throws ParseException {
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    label_8:
    while (true) {
      OrderCondition();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STR:
      case IS_URI:
      case LANG:
      case IS_IRI:
      case LANGMATCHES:
      case IS_BLANK:
      case IS_LITERAL:
      case DATATYPE:
      case REGEX:
      case BOUND:
      case SAME_TERM:
      case 42:
      case 43:
      case 47:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
    }
  }

/* [17]    OrderCondition    ::=     ( ( 'ASC' | 'DESC' ) BrackettedExpression ) | ( Constraint | Var ) */
  final public void OrderCondition() throws ParseException {
                          boolean asc = true; Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 42:
    case 43:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 42:
        jj_consume_token(42);
        break;
      case 43:
        jj_consume_token(43);
                       asc = false;
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      e = BrackettedExpression();
      break;
    case STR:
    case IS_URI:
    case LANG:
    case IS_IRI:
    case LANGMATCHES:
    case IS_BLANK:
    case IS_LITERAL:
    case DATATYPE:
    case REGEX:
    case BOUND:
    case SAME_TERM:
    case 47:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case VAR1:
    case VAR2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STR:
      case IS_URI:
      case LANG:
      case IS_IRI:
      case LANGMATCHES:
      case IS_BLANK:
      case IS_LITERAL:
      case DATATYPE:
      case REGEX:
      case BOUND:
      case SAME_TERM:
      case 47:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
        e = Constraint();
        break;
      case VAR1:
      case VAR2:
        e = Var();
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    queryStructure.addOrdering(e, asc);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* [18]    LimitClause    ::=    'LIMIT' INTEGER */
  final public void LimitClause() throws ParseException {
                       Token t;
    jj_consume_token(LIMIT);
    t = jj_consume_token(INTEGER);
                          queryStructure.setLimit(t.image);
  }

/* [19]    OffsetClause    ::=    'OFFSET' INTEGER */
  final public void OffsetClause() throws ParseException {
                        Token t;
    jj_consume_token(OFFSET);
    t = jj_consume_token(INTEGER);
                           queryStructure.setOffset(t.image);
  }

/* [20]    GroupGraphPattern    ::=    '{' TriplesBlock? ( ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock? )* '}' */
  final public GroupGraphPattern GroupGraphPattern() throws ParseException {
  GroupGraphPattern g = null, g2;
  GraphPatternConjunction c = null;
  Expression f;
          g = GroupGraphPattern.EMPTY;
    jj_consume_token(44);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case 47:
    case 53:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      g = TriplesBlock();
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GRAPH:
      case OPTIONAL:
      case FILTER:
      case LET:
      case 44:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GRAPH:
      case OPTIONAL:
      case LET:
      case 44:
        g = GraphPatternNotTriples(g);
        break;
      case FILTER:
        f = Filter();
            if (g == null) {if (true) throw new ParseException("Cannot filter an empty pattern");}
            g.setFilter(f);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 45:
        jj_consume_token(45);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case 47:
      case 53:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        g2 = TriplesBlock();
            if (g == null) g = g2;
            else {
                    // preferentially choose c so we get the right constructor
                    if (c == null) c = new GraphPatternConjunction(g, g2);
                    else c = new GraphPatternConjunction(c, g2);
                    g = c;
            }
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
    }
    jj_consume_token(46);
      {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

/* [21]    TriplesBlock    ::=    TriplesSameSubject ( '.' TriplesBlock? )? */
  final public GraphPatternConjunction TriplesBlock() throws ParseException {
                                           TripleList l; GraphPatternConjunction g = null;
    l = TriplesSameSubject();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 45:
      jj_consume_token(45);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case 47:
      case 53:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        g = TriplesBlock();
                                                     g = new GraphPatternConjunction(g, l);
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
      if (g == null) {if (true) return new GraphPatternConjunction(l);}
      {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

/* [22]    GraphPatternNotTriples    ::=    OptionalGraphPattern | GroupOrUnionGraphPattern | GraphGraphPattern */
  final public GroupGraphPattern GraphPatternNotTriples(GroupGraphPattern in) throws ParseException {
                                                                   GroupGraphPattern g;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPTIONAL:
      g = OptionalGraphPattern(in);
      break;
    case 44:
      g = GroupOrUnionGraphPattern(in);
      break;
    case GRAPH:
      g = GraphGraphPattern(in);
      break;
    case LET:
      g = Assignment(in);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return g;}
    throw new Error("Missing return statement in function");
  }

/* [23]    OptionalGraphPattern    ::=    'OPTIONAL' GroupGraphPattern */
  final public GroupGraphPattern OptionalGraphPattern(GroupGraphPattern in) throws ParseException {
                                                                 GroupGraphPattern g;
    jj_consume_token(OPTIONAL);
    g = GroupGraphPattern();
                                       {if (true) return new GraphPatternOptional(in, g);}
    throw new Error("Missing return statement in function");
  }

/* [24]    GraphGraphPattern    ::=    'GRAPH' VarOrIRIref GroupGraphPattern */
  final public GroupGraphPattern GraphGraphPattern(GroupGraphPattern in) throws ParseException {
                                                              Expression e; GroupGraphPattern g;
    jj_consume_token(GRAPH);
    e = VarOrIRIref();
    g = GroupGraphPattern();
      g.setGraph(e);
      {if (true) return conjoin(in, g);}
    throw new Error("Missing return statement in function");
  }

/* SPARQL Extension */
/* Assignment  ::=  'LET (' Var ':=' Expression ')' */
  final public GroupGraphPattern Assignment(GroupGraphPattern in) throws ParseException {
                                                       Variable v ; Expression expr ;
    jj_consume_token(LET);
    jj_consume_token(47);
    v = Var();
    jj_consume_token(48);
    expr = Expression();
    jj_consume_token(49);
      {if (true) return new VarAssign(in, v, expr) ;}
    throw new Error("Missing return statement in function");
  }

/* [25]    GroupOrUnionGraphPattern    ::=    GroupGraphPattern ( 'UNION' GroupGraphPattern )* */
  final public GroupGraphPattern GroupOrUnionGraphPattern(GroupGraphPattern in) throws ParseException {
                                                                     GroupGraphPattern g1, g2; GraphPatternDisjunction d = null;
    g1 = GroupGraphPattern();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_10;
      }
      jj_consume_token(UNION);
      g2 = GroupGraphPattern();
        // use an existing disjunction if available, to pick the correct constructor
        if (d == null) d = new GraphPatternDisjunction(g1, g2);
        else d = new GraphPatternDisjunction(d, g2);
        g1 = d;
    }
      {if (true) return conjoin(in, g1);}
    throw new Error("Missing return statement in function");
  }

/* [26]    Filter    ::=    'FILTER' Constraint */
  final public Expression Filter() throws ParseException {
                        Expression e;
    jj_consume_token(FILTER);
    e = Constraint();
                              {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [27]    Constraint    ::=    BrackettedExpression | BuiltInCall | FunctionCall */
  final public Expression Constraint() throws ParseException {
                            Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
      e = BrackettedExpression();
      break;
    case STR:
    case IS_URI:
    case LANG:
    case IS_IRI:
    case LANGMATCHES:
    case IS_BLANK:
    case IS_LITERAL:
    case DATATYPE:
    case REGEX:
    case BOUND:
    case SAME_TERM:
      e = BuiltInCall();
      break;
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
      e = FunctionCall();
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [28]    FunctionCall    ::=    IRIref ArgList */
  final public FunctionCall FunctionCall() throws ParseException {
                                IRIReference r; ArgList l;
    r = IRIref();
    l = ArgList();
      {if (true) return new FunctionCall(r, l);}
    throw new Error("Missing return statement in function");
  }

/* [29]    ArgList    ::=    ( NIL | '(' Expression ( ',' Expression )* ')' ) */
  final public ArgList ArgList() throws ParseException {
                      ArgList list = new ArgList(); Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NIL:
      jj_consume_token(NIL);
      break;
    case 47:
      jj_consume_token(47);
      e = Expression();
                             list.add(e);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 50:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_11;
        }
        jj_consume_token(50);
        e = Expression();
                                                                   list.add(e);
      }
      jj_consume_token(49);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/* [30]    ConstructTemplate    ::=    '{' ConstructTriples? '}' */
  final public void ConstructTemplate() throws ParseException {
                             TripleList triples = null;
    jj_consume_token(44);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case 47:
    case 53:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      triples = ConstructTriples();
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    jj_consume_token(46);
      queryStructure.setConstructTemplate(triples);
  }

/* [31]    ConstructTriples    ::=    TriplesSameSubject ( '.' ConstructTriples? )? */
  final public TripleList ConstructTriples() throws ParseException {
                                  TripleList triples, t;
    triples = TriplesSameSubject();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 45:
      jj_consume_token(45);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case 47:
      case 53:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        t = ConstructTriples();
                                                               triples.concat(t);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
      {if (true) return triples;}
    throw new Error("Missing return statement in function");
  }

/* [32]    TriplesSameSubject    ::=    VarOrTerm PropertyListNotEmpty |  TriplesNode PropertyList */
  final public TripleList TriplesSameSubject() throws ParseException {
                                    Node s; AnnotatedNode an; PropertyList pl;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      s = VarOrTerm();
      pl = PropertyListNotEmpty();
                                              {if (true) return new TripleList(s, pl);}
      break;
    case 47:
    case 53:
      an = TriplesNode();
      pl = PropertyList();
                                         {if (true) return new TripleList(an, pl);}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [33]    PropertyListNotEmpty    ::=    Verb ObjectList ( ';' ( Verb ObjectList )? )* */
  final public PropertyList PropertyListNotEmpty() throws ParseException {
                                        Node v; List<Node> o; PropertyList pl = new PropertyList();
    v = Verb();
    o = ObjectList();
                              pl.add(v, o);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 51:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_12;
      }
      jj_consume_token(51);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 52:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
        v = Verb();
        o = ObjectList();
                                      pl.add(v, o);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
    }
      {if (true) return pl;}
    throw new Error("Missing return statement in function");
  }

/* [34]    PropertyList    ::=    PropertyListNotEmpty? */
  final public PropertyList PropertyList() throws ParseException {
                                PropertyList pl = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 52:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case VAR1:
    case VAR2:
      pl = PropertyListNotEmpty();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
      {if (true) return pl == null ? new PropertyList() : pl;}
    throw new Error("Missing return statement in function");
  }

/* [35]    ObjectList    ::=    Object ( ',' Object )* */
  final public List<Node> ObjectList() throws ParseException {
                            List<Node> l; Node n;
          l = new LinkedList<Node>();
    n = Object();
                 l.add(n);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_13;
      }
      jj_consume_token(50);
      Object();
                     l.add(n);
    }
      {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

/* [36]    Object    ::=    GraphNode */
  final public Node Object() throws ParseException {
                  Node n;
    n = GraphNode();
                    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* [37]    Verb    ::=    VarOrIRIref | 'a' */
  final public Expression Verb() throws ParseException {
                      Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case VAR1:
    case VAR2:
      e = VarOrIRIref();
                      {if (true) return e;}
      break;
    case 52:
      jj_consume_token(52);
            {if (true) return IRIReference.RDF_TYPE;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// Return a node AND a conjunction to the current context
/* [38]    TriplesNode    ::=    Collection |  BlankNodePropertyList */
  final public AnnotatedNode TriplesNode() throws ParseException {
                                AnnotatedNode n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
      n = Collection();
      break;
    case 53:
      n = BlankNodePropertyList();
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* [39]    BlankNodePropertyList    ::=    '[' PropertyListNotEmpty ']' */
  final public AnnotatedNode BlankNodePropertyList() throws ParseException {
                                          PropertyList pl;
    jj_consume_token(53);
    pl = PropertyListNotEmpty();
    jj_consume_token(54);
      {if (true) return new AnnotatedNode(queryStructure.newBlankNode(), pl);}
    throw new Error("Missing return statement in function");
  }

/* [40]    Collection    ::=    '(' GraphNode+ ')' */
/* Returns a *NODE* that is a collection.  The rest of the collection will be conjoined after. */
  final public AnnotatedNode Collection() throws ParseException {
                               Node n; GraphList l = queryStructure.newList();
    jj_consume_token(47);
    label_14:
    while (true) {
      n = GraphNode();
                       l.add(n);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case 47:
      case 53:
      case IRI_REF:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_14;
      }
    }
    jj_consume_token(49);
      {if (true) return new AnnotatedNode(l);}
    throw new Error("Missing return statement in function");
  }

/* [41]    GraphNode    ::=    VarOrTerm |  TriplesNode */
  final public Node GraphNode() throws ParseException {
                     Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case BLANK_NODE_LABEL:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      n = VarOrTerm();
      break;
    case 47:
    case 53:
      n = TriplesNode();
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* [42]    VarOrTerm    ::=    Var | GraphTerm */
  final public Node VarOrTerm() throws ParseException {
                     Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      n = Var();
      break;
    case TRUE:
    case FALSE:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case BLANK_NODE_LABEL:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
    case NIL:
    case ANON:
      n = GraphTerm();
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* [43]    VarOrIRIref    ::=    Var | IRIref */
  final public Expression VarOrIRIref() throws ParseException {
                             Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
    case VAR2:
      e = Var();
      break;
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
      e = IRIref();
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [44]    Var    ::=    VAR1 | VAR2 */
  final public Variable Var() throws ParseException {
                   Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR1:
      t = jj_consume_token(VAR1);
      break;
    case VAR2:
      t = jj_consume_token(VAR2);
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                            {if (true) return queryStructure.newVariable(t.image);}
    throw new Error("Missing return statement in function");
  }

/* [45]    GraphTerm    ::=    IRIref |  RDFLiteral |  NumericLiteral |  BooleanLiteral |  BlankNode |  NIL */
  final public Node GraphTerm() throws ParseException {
                     Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
      n = IRIref();
      break;
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      n = RDFLiteral();
      break;
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
      n = NumericLiteral();
      break;
    case TRUE:
    case FALSE:
      n = BooleanLiteral();
      break;
    case BLANK_NODE_LABEL:
    case ANON:
      n = BlankNode();
      break;
    case NIL:
      jj_consume_token(NIL);
                                                                                                     n = NIL_NODE;
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/* [46]    Expression    ::=    ConditionalOrExpression */
  final public Expression Expression() throws ParseException {
                            Expression e;
    e = ConditionalOrExpression();
                                  {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [47]    ConditionalOrExpression    ::=    ConditionalAndExpression ( '||' ConditionalAndExpression )* */
  final public Expression ConditionalOrExpression() throws ParseException {
                                         Expression e, ae;
    e = ConditionalAndExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 55:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_15;
      }
      jj_consume_token(55);
      ae = ConditionalAndExpression();
                                                                        e = new OrExpression(e, ae);
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [48]    ConditionalAndExpression    ::=    ValueLogical ( '&&' ValueLogical )* */
  final public Expression ConditionalAndExpression() throws ParseException {
                                          Expression e, e2;
    e = ValueLogical();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_16;
      }
      jj_consume_token(56);
      e2 = ValueLogical();
                                                e = new AndExpression(e, e2);
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [49]    ValueLogical    ::=    RelationalExpression */
  final public Expression ValueLogical() throws ParseException {
                              Expression e;
    e = RelationalExpression();
                               {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [50]    RelationalExpression    ::=    NumericExpression ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression )? */
  final public Expression RelationalExpression() throws ParseException {
                                      Expression e, e2;
    e = NumericExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 57:
        jj_consume_token(57);
        e2 = NumericExpression();
                                   e = new Equals(e, e2);
        break;
      case 58:
        jj_consume_token(58);
        e2 = NumericExpression();
                                      e = new NotEquals(e, e2);
        break;
      case 59:
        jj_consume_token(59);
        e2 = NumericExpression();
                                     e = new LessThan(e, e2);
        break;
      case 60:
        jj_consume_token(60);
        e2 = NumericExpression();
                                     e = new GreaterThan(e, e2);
        break;
      case 61:
        jj_consume_token(61);
        e2 = NumericExpression();
                                      e = new LessThanEqual(e, e2);
        break;
      case 62:
        jj_consume_token(62);
        e2 = NumericExpression();
                                      e = new GreaterThanEqual(e, e2);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [51]    NumericExpression    ::=    AdditiveExpression */
  final public Expression NumericExpression() throws ParseException {
                                   Expression e;
    e = AdditiveExpression();
                             {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [52]    AdditiveExpression    ::=    MultiplicativeExpression ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | NumericLiteralPositive | NumericLiteralNegative )* */
  final public Expression AdditiveExpression() throws ParseException {
                                    Expression e, e2;
    e = MultiplicativeExpression();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 63:
      case 64:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_17;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 63:
        jj_consume_token(63);
        e2 = MultiplicativeExpression();
                                          e = new Plus(e, e2);
        break;
      case 64:
        jj_consume_token(64);
        e2 = MultiplicativeExpression();
                                            e = new Minus(e, e2);
        break;
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
        e2 = NumericLiteralPositive();
                                      e = new Plus(e, e2);
        break;
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        e2 = NumericLiteralNegative();
                                      e = new Minus(e, e2);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [53]    MultiplicativeExpression    ::=    UnaryExpression ( '*' UnaryExpression | '/' UnaryExpression )* */
  final public Expression MultiplicativeExpression() throws ParseException {
                                          Expression e, e2;
    e = UnaryExpression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 41:
      case 65:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_18;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 41:
        jj_consume_token(41);
        e2 = UnaryExpression();
                                 e = new Multiply(e, e2);
        break;
      case 65:
        jj_consume_token(65);
        e2 = UnaryExpression();
                                   e = new Divide(e, e2);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [54]    UnaryExpression    ::=      '!' PrimaryExpression  |  '+' PrimaryExpression  | '-' PrimaryExpression  | PrimaryExpression */
  final public Expression UnaryExpression() throws ParseException {
                                 Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 66:
      jj_consume_token(66);
      e = PrimaryExpression();
                                {if (true) return new Not(e);}
      break;
    case 63:
      jj_consume_token(63);
      e = PrimaryExpression();
                                  {if (true) return new UnaryPlus(e);}
      break;
    case 64:
      jj_consume_token(64);
      e = PrimaryExpression();
                                  {if (true) return new UnaryMinus(e);}
      break;
    case STR:
    case IS_URI:
    case LANG:
    case IS_IRI:
    case LANGMATCHES:
    case IS_BLANK:
    case IS_LITERAL:
    case DATATYPE:
    case REGEX:
    case BOUND:
    case TRUE:
    case SAME_TERM:
    case FALSE:
    case 47:
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
    case VAR1:
    case VAR2:
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      e = PrimaryExpression();
                              {if (true) return e;}
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [55]    PrimaryExpression    ::=    BrackettedExpression | BuiltInCall | IRIrefOrFunction | RDFLiteral | NumericLiteral | BooleanLiteral | Var */
  final public Expression PrimaryExpression() throws ParseException {
                                   Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
      e = BrackettedExpression();
      break;
    case STR:
    case IS_URI:
    case LANG:
    case IS_IRI:
    case LANGMATCHES:
    case IS_BLANK:
    case IS_LITERAL:
    case DATATYPE:
    case REGEX:
    case BOUND:
    case SAME_TERM:
      e = BuiltInCall();
      break;
    case IRI_REF:
    case PNAME_NS:
    case PNAME_LN:
      e = IRIrefOrFunction();
      break;
    case STRING_LITERAL1:
    case STRING_LITERAL2:
    case STRING_LITERAL_LONG1:
    case STRING_LITERAL_LONG2:
      e = RDFLiteral();
      break;
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
      e = NumericLiteral();
      break;
    case TRUE:
    case FALSE:
      e = BooleanLiteral();
      break;
    case VAR1:
    case VAR2:
      e = Var();
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [56]    BrackettedExpression    ::=    '(' Expression ')' */
  final public Expression BrackettedExpression() throws ParseException {
                                      Expression e;
    jj_consume_token(47);
    e = Expression();
    jj_consume_token(49);
                             {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/* [57]    BuiltInCall    ::=      'STR' '(' Expression ')' */
/* |  'LANG' '(' Expression ')' */
/* |  'LANGMATCHES' '(' Expression ',' Expression ')' */
/* |  'DATATYPE' '(' Expression ')' */
/* |  'BOUND' '(' Var ')' */
/* |  'sameTerm' '(' Expression ',' Expression ')' */
/* |  'isIRI' '(' Expression ')' */
/* |  'isURI' '(' Expression ')' */
/* |  'isBLANK' '(' Expression ')' */
/* |  'isLITERAL' '(' Expression ')' */
/* |  RegexExpression */
  final public BuiltInCall BuiltInCall() throws ParseException {
                              Expression e, e2; Variable v;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STR:
      jj_consume_token(STR);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                   {if (true) return new BicStr(e);}
      break;
    case LANG:
      jj_consume_token(LANG);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                      {if (true) return new BicLang(e);}
      break;
    case LANGMATCHES:
      jj_consume_token(LANGMATCHES);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(50);
      e2 = Expression();
      jj_consume_token(49);
                                                                 {if (true) return new BicLangMatches(e, e2);}
      break;
    case DATATYPE:
      jj_consume_token(DATATYPE);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                          {if (true) return new BicDatatype(e);}
      break;
    case BOUND:
      jj_consume_token(BOUND);
      jj_consume_token(47);
      v = Var();
      jj_consume_token(49);
                                {if (true) return new BicBound(v);}
      break;
    case SAME_TERM:
      jj_consume_token(SAME_TERM);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(50);
      e2 = Expression();
      jj_consume_token(49);
                                                               {if (true) return new BicSameTerm(e, e2);}
      break;
    case IS_IRI:
      jj_consume_token(IS_IRI);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                        {if (true) return new BicIsIri(e);}
      break;
    case IS_URI:
      jj_consume_token(IS_URI);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                        {if (true) return new BicIsUri(e);}
      break;
    case IS_BLANK:
      jj_consume_token(IS_BLANK);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                          {if (true) return new BicIsBlank(e);}
      break;
    case IS_LITERAL:
      jj_consume_token(IS_LITERAL);
      jj_consume_token(47);
      e = Expression();
      jj_consume_token(49);
                                            {if (true) return new BicIsLiteral(e);}
      break;
    case REGEX:
      e = RegexExpression();
                            {if (true) return (BuiltInCall)e;}
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [58]    RegexExpression    ::=    'REGEX' '(' Expression ',' Expression ( ',' Expression )? ')' */
  final public BuiltInCall RegexExpression() throws ParseException {
                                  Expression e1, e2, e3 = null;
    jj_consume_token(REGEX);
    jj_consume_token(47);
    e1 = Expression();
    jj_consume_token(50);
    e2 = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 50:
      jj_consume_token(50);
      e3 = Expression();
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    jj_consume_token(49);
      {if (true) return new BicRegEx(e1, e2, e3);}
    throw new Error("Missing return statement in function");
  }

/* [59]    IRIrefOrFunction    ::=    IRIref ArgList? */
  final public Expression IRIrefOrFunction() throws ParseException {
                                  IRIReference ref; ArgList list;
    ref = IRIref();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
    case NIL:
      list = ArgList();
                                   {if (true) return new FunctionCall(ref, list);}
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
      {if (true) return ref;}
    throw new Error("Missing return statement in function");
  }

/* [60]    RDFLiteral    ::=    String ( LANGTAG | ( '^^' IRIref ) )? */
  final public RDFLiteral RDFLiteral() throws ParseException {
                            Token t; RDFLiteral l; String s; IRIReference ref;
    s = String();
                   l = new RDFLiteral(s);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 67:
    case LANGTAG:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LANGTAG:
        t = jj_consume_token(LANGTAG);
                    l.setLanguage(t.image);
        break;
      case 67:
        jj_consume_token(67);
        ref = IRIref();
                            l.setDatatype(ref);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
      {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

/* [61]    NumericLiteral    ::=    NumericLiteralUnsigned | NumericLiteralPositive | NumericLiteralNegative */
  final public NumericLiteral NumericLiteral() throws ParseException {
                                    NumericLiteral l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case DECIMAL:
    case DOUBLE:
      l = NumericLiteralUnsigned();
      break;
    case INTEGER_POSITIVE:
    case DECIMAL_POSITIVE:
    case DOUBLE_POSITIVE:
      l = NumericLiteralPositive();
      break;
    case INTEGER_NEGATIVE:
    case DECIMAL_NEGATIVE:
    case DOUBLE_NEGATIVE:
      l = NumericLiteralNegative();
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

/* [62]    NumericLiteralUnsigned    ::=    INTEGER |  DECIMAL |  DOUBLE */
  final public NumericLiteral NumericLiteralUnsigned() throws ParseException {
                                            Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                  {if (true) return new IntegerLiteral(t.image);}
      break;
    case DECIMAL:
      t = jj_consume_token(DECIMAL);
                    {if (true) return new DecimalLiteral(t.image);}
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
                   {if (true) return new DoubleLiteral(t.image);}
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [63]    NumericLiteralPositive    ::=    INTEGER_POSITIVE |  DECIMAL_POSITIVE |  DOUBLE_POSITIVE */
  final public NumericLiteral NumericLiteralPositive() throws ParseException {
                                            Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_POSITIVE:
      t = jj_consume_token(INTEGER_POSITIVE);
                           {if (true) return new IntegerLiteral(t.image);}
      break;
    case DECIMAL_POSITIVE:
      t = jj_consume_token(DECIMAL_POSITIVE);
                             {if (true) return new DecimalLiteral(t.image);}
      break;
    case DOUBLE_POSITIVE:
      t = jj_consume_token(DOUBLE_POSITIVE);
                            {if (true) return new DoubleLiteral(t.image);}
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [64]    NumericLiteralNegative    ::=    INTEGER_NEGATIVE |  DECIMAL_NEGATIVE |  DOUBLE_NEGATIVE */
  final public NumericLiteral NumericLiteralNegative() throws ParseException {
                                            Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_NEGATIVE:
      t = jj_consume_token(INTEGER_NEGATIVE);
                           {if (true) return new IntegerLiteral(t.image);}
      break;
    case DECIMAL_NEGATIVE:
      t = jj_consume_token(DECIMAL_NEGATIVE);
                             {if (true) return new DecimalLiteral(t.image);}
      break;
    case DOUBLE_NEGATIVE:
      t = jj_consume_token(DOUBLE_NEGATIVE);
                            {if (true) return new DoubleLiteral(t.image);}
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [65]    BooleanLiteral    ::=    'true' |  'false' */
  final public BooleanLiteral BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
             {if (true) return BooleanLiteral.TRUE;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
                {if (true) return BooleanLiteral.FALSE;}
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [66]    String    ::=    STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 */
  final public String String() throws ParseException {
                    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL1:
      t = jj_consume_token(STRING_LITERAL1);
                          {if (true) return unquote(t.image) ;}
      break;
    case STRING_LITERAL2:
      t = jj_consume_token(STRING_LITERAL2);
                            {if (true) return unquote(t.image) ;}
      break;
    case STRING_LITERAL_LONG1:
      t = jj_consume_token(STRING_LITERAL_LONG1);
                                 {if (true) return unTripleQuote(t.image) ;}
      break;
    case STRING_LITERAL_LONG2:
      t = jj_consume_token(STRING_LITERAL_LONG2);
                                 {if (true) return unTripleQuote(t.image) ;}
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [67]    IRIref    ::=    IRI_REF |  PrefixedName */
  final public IRIReference IRIref() throws ParseException {
                          IRIReference i; Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IRI_REF:
      t = jj_consume_token(IRI_REF);
                  {if (true) return queryStructure.newIRIRef(unquote(t.image));}
      break;
    case PNAME_NS:
    case PNAME_LN:
      i = PrefixedName();
                         {if (true) return i;}
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* [68]    PrefixedName    ::=    PNAME_LN | PNAME_NS */
  final public IRIReference PrefixedName() throws ParseException {
                                Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PNAME_LN:
      t = jj_consume_token(PNAME_LN);
      break;
    case PNAME_NS:
      t = jj_consume_token(PNAME_NS);
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return queryStructure.newPrefixedName(t.image);}
    throw new Error("Missing return statement in function");
  }

/* [69]    BlankNode    ::=    BLANK_NODE_LABEL |  ANON */
  final public BlankNode BlankNode() throws ParseException {
                          Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLANK_NODE_LABEL:
      t = jj_consume_token(BLANK_NODE_LABEL);
                           {if (true) return new BlankNode(t.image);}
      break;
    case ANON:
      jj_consume_token(ANON);
               {if (true) return queryStructure.newBlankNode();}
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public SparqlParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[77];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x40820100,0x200,0x10000,0x80000000,0x80000000,0x0,0x0,0x1000,0x1000,0x0,0x0,0x1000,0x2000000,0x1000,0x80000,0x2000000,0x400,0x1040000,0x1000000,0x40000,0x1040000,0x3860c000,0x0,0x3860c000,0x3860c000,0x0,0x102000,0x102000,0x0,0x0,0x0,0x0,0x102000,0x4000000,0x3860c000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3860c000,0x3860c000,0x3860c000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x8,0x8,0x0,0x200,0x0,0x0,0x0,0x200,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8c56,0xc00,0x8056,0x8c56,0x2080a0,0x1101,0x1101,0x2000,0x2080a0,0x2080a0,0x2000,0x1100,0x0,0x8056,0x40000,0x8000,0x2080a0,0x2080a0,0x2000,0x2080a0,0x80000,0x100000,0x100000,0x40000,0x100000,0x208000,0x2080a0,0x2080a0,0xa0,0x0,0x0,0xa0,0x800000,0x1000000,0x7e000000,0x7e000000,0x80000000,0x80000000,0x200,0x200,0x800080f6,0x80f6,0x56,0x40000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0xa0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x300,0x300,0x0,0x0,0x370,0x370,0x0,0x0,0x0,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x370,0x0,0x370,0x370,0xaf7fc3f0,0x0,0x0,0x0,0xaf7fc3f0,0xaf7fc3f0,0x0,0x0,0x0,0x70,0x0,0x20000000,0xaf7fc3f0,0xaf7fc3f0,0x0,0xaf7fc3f0,0x0,0x370,0x370,0x0,0x370,0x0,0xaf7fc3f0,0xaf7fc3f0,0xaf7fc3f0,0x370,0x300,0xaf7fc0f0,0x0,0x0,0x0,0x0,0x7e0001,0x7e0001,0x2,0x2,0xf7fc375,0xf7fc370,0x0,0x0,0x20000000,0x408,0x408,0x7fc000,0x1c000,0xe0000,0x700000,0x0,0xf000000,0x70,0x60,0x80000080,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  public SparqlParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public SparqlParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SparqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  public SparqlParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SparqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  public SparqlParser(SparqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  public void ReInit(SparqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[102];
    for (int i = 0; i < 102; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 77; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 102; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
