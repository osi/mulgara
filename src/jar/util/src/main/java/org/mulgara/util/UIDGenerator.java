/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Kowari Metadata Store.
 *
 * The Initial Developer of the Original Code is Plugged In Software Pty
 * Ltd (http://www.pisoftware.com, mailto:info@pisoftware.com). Portions
 * created by Plugged In Software Pty Ltd are Copyright (C) 2001,2002
 * Plugged In Software Pty Ltd. All Rights Reserved.
 *
 * Contributor(s): N/A.
 *
 * [NOTE: The text of this Exhibit A may differ slightly from the text
 * of the notices in the Source Code files of the Original Code. You
 * should use the text of this Exhibit A rather than the text found in the
 * Original Code Source Code for Your Modifications.]
 *
 */

package org.mulgara.util;

//Java 2 standard packages
import java.net.*;
import java.rmi.dgc.*;
import java.security.*;
import java.nio.*;

/**
 * Utility class that generates an Unique identifier.
 *
 * @created 2004-09-29
 *
 * @author <a href="mailto:robert.turner@tucanatech.com">Robert Turner</a>
 *
 * @version $Revision: 1.10 $
 *
 * @modified $Date: 2005/02/03 20:07:37 $ by $Author: newmana $
 *
 * @company <a href="http://www.tucanatech.com/">Tucana Technologies</a>
 *
 * @copyright &copy;2001 <a href="http://www.pisoftware.com/">Plugged In
 *   Software Pty Ltd</a>
 *
 * @licence <a href="{@docRoot}/../../LICENCE">Mozilla Public License v1.1</a>
 */
public class UIDGenerator {

  /** Computers IP address */
  private static String ipAddress = null;

  /** Unique Java Virtual Machine Identifier */
  private static String vmID = null;

  /** time the method was called (used to prevent duplicates) */
  private static long callTime = 0;

  /** count of UIDs generated by this JVM (to avoid per millisecond duplicates). */
  private static long uidCounter = 0;

  /**
   * Generates an Unique Identifier using the current time and the machines
   * IP address.
   *
   * @throws Exception
   * @return String
   */
  public synchronized static String generateUID() throws Exception {
    String uniqueID = getUniqueID(getSeed());
    return uniqueID;
  }

  /**
   * Returns a MD5 sum of the seed.
   *
   * @param seed char[]
   * @throws Exception
   * @return String
   */
  private synchronized static String getUniqueID(char[] seed) throws
      Exception {

    String uid = null;

    //digest the seed and convert to hex
    byte[] digested = digest(seed);
    StringBuffer buffer = new StringBuffer();
    int currentInt = 0;

    //convert each byte to an int (as hex)
    for (int i = 0; i < digested.length; ++i) {

      //conver to int
      currentInt = digested[i] & 0xFF;

      //is the int smaller than 16? (single digit hex)
      if (currentInt < 0x10) {

        buffer.append('0');
      }

      buffer.append(Integer.toHexString(currentInt));
    }

    uid = buffer.toString();

    //validate
    if (uid == null) {

      throw new Exception("Failed to generate UID.");
    }

    return uid;
  }

  /**
   * Returns an MD5 sum for the char []
   *
   * @param chars []
   * @throws Exception
   * @return byte[]
   */
  private static byte[] digest(char[] chars) throws Exception {

    //validate
    if (chars == null) {

      throw new IllegalArgumentException("Cannot get MD5 sum for null char [].");
    }

    try {

      MessageDigest digest = MessageDigest.getInstance("MD5");

      //add the chars to the buffer
      int bufferSize = chars.length * 2;
      ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
      for (int i = 0; i < chars.length; i++) {

        buffer.putChar(chars[i]);
      }

      //digest
      return digest.digest(buffer.array());
    }
    catch (NoSuchAlgorithmException algorithmException) {

      throw new Exception("Could not get MD5 algorithm.", algorithmException);
    }
  }

  /**
   * Returns an unique seed.
   *
   * @throws Exception
   * @return char []
   */
  private synchronized static char[] getSeed() throws Exception {

    StringBuffer seed = new StringBuffer();

    //location in universe (cyberspace). A JVM running on a particular machine.
    seed.append(getIP());
    seed.append(getJVMID());
    //time (current millisecond)
    seed.append(getTime());
    //random, allows multiple new UIDS per millisecond. (validated by List)
    seed.append(getRandom());
    //another Class could be generating UIDS the same way within the same JVM
    seed.append(UIDGenerator.class.getName());
    //two random numbers could (possibly) be generated in the same millisecond
    seed.append(getCount());
    //more than one UIDGenerator class may be loaded by different ClassLoaders
    seed.append(getClassLoaderId());

    //conver to char []
    char[] chars = new char[seed.length()];
    seed.getChars(0, seed.length(), chars, 0);

    return chars;
  }

  /**
   * Returns a Random number/String.
   *
   * @return String
   */
  private synchronized static String getRandom() {

    long random = new SecureRandom().nextLong();

    return "" + random;
  }

  /**
   * Returns the current time in milliseconds.
   *
   * @return String
   */
  private synchronized static String getTime() {

    callTime = System.currentTimeMillis();

    return "" + callTime;
  }

  /**
   * Returns an incremented count of UIDs generated by this instance.
   * @return long
   */
  private synchronized static long getCount() {
    return++uidCounter;
  }

  /**
   * Returns the IP address for this machine.
   *
   * @throws Exception
   * @return String
   */
  private synchronized static String getIP() throws Exception {

    try {

      //lazily obtain IP address
      if (ipAddress == null) {

        ipAddress = InetAddress.getLocalHost().getHostAddress();
      }

      return ipAddress;
    }
    catch (UnknownHostException hostException) {

      throw new Exception("Could not determine IP Address.", hostException);
    }
  }

  /**
   * Returns an Unique Identifier for this particular Java Virtual Machine.
   *
   * @throws Exception
   * @return String
   */
  private synchronized static String getJVMID() throws Exception {

    //lazily obtain JVM ID
    if (vmID == null) {

      vmID = new VMID().toString();
    }

    return vmID;
  }

  /**
   * If multiple UIDGenerators are loaded by different class loaders, they
   * will be operating independantly of each other (ie. multiple web
   * applications within an application server), It is (remotely) possible
   * that multiple UIDGenerator may duplicate their count and random numbers
   * within the same millisecond.
   *
   * @return int
   */
  private synchronized static int getClassLoaderId() {
    //what ClassLoader within this JVM loaded this UIDGenerator class
    int classLoaderId = System.identityHashCode(UIDGenerator.class.
        getClassLoader());
    return classLoaderId;
  }
}
