/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the Kowari Metadata Store.
 *
 * The Initial Developer of the Original Code is Plugged In Software Pty
 * Ltd (http://www.pisoftware.com, mailto:info@pisoftware.com). Portions
 * created by Plugged In Software Pty Ltd are Copyright (C) 2001,2002
 * Plugged In Software Pty Ltd. All Rights Reserved.
 *
 * Contributor(s): N/A.
 *
 * [NOTE: The text of this Exhibit A may differ slightly from the text
 * of the notices in the Source Code files of the Original Code. You
 * should use the text of this Exhibit A rather than the text found in the
 * Original Code Source Code for Your Modifications.]
 *
 */

package org.mulgara.content.rio;

// Java 2 standard packages
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.*;
import org.xml.sax.*;
import org.xml.sax.helpers.LocatorImpl;

// Third party packages
import org.apache.log4j.Logger;      // Apache Log4J
import org.jrdf.graph.*;             // JRDF
import org.jrdf.graph.mem.GraphImpl;
import org.jrdf.parser.Parser;
import org.jrdf.parser.ParseErrorListener;
import org.jrdf.parser.StatementHandler;
import org.jrdf.parser.StatementHandlerException;
import org.jrdf.parser.rdfxml.RdfXmlParser;

// Locally written packages
import org.mulgara.content.Content;
import org.mulgara.content.NotModifiedException;
import org.mulgara.query.Constraint;
import org.mulgara.query.Cursor;
import org.mulgara.query.QueryException;
import org.mulgara.query.TuplesException;
import org.mulgara.query.Variable;
import org.mulgara.query.rdf.*;
import org.mulgara.resolver.spi.LocalizeException;
import org.mulgara.resolver.spi.ResolverSession;
import org.mulgara.resolver.spi.Statements;
import org.mulgara.resolver.spi.StatementsWrapperResolution;
import org.mulgara.store.StoreException;
import org.mulgara.store.tuples.AbstractTuples;
import org.mulgara.store.tuples.Tuples;

/**
 * This {@link Runnable} 
 *
 * @created 2004-04-02
 * @author <a href="http://staff.pisoftware.com/davidm">David Makepeace</a>
 * @author <a href="http://staff.pisoftware.com/raboczi">Simon Raboczi</a>
 * @version $Revision: 1.8 $
 * @modified $Date: 2005/01/05 04:58:04 $ @maintenanceAuthor $Author: newmana $
 * @company <a href="mailto:info@PIsoftware.com">Plugged In Software</a>
 * @copyright &copy; 2004 <a href="http://www.PIsoftware.com/">Plugged In
 *      Software Pty Ltd</a>
 * @licence <a href="{@docRoot}/../../LICENCE">Mozilla Public License v1.1</a>
 */
class ParserThread extends Thread
  implements ParseErrorListener, StatementHandler
{
  /**
   * Logger.
   */
  private static final Logger logger =
    Logger.getLogger(ParserThread.class.getName());

  private final int BUFFER_SIZE = 100;

  /**
   * Maximum size that {@link #queue} can attain without the
   * parser deliberately blocking and waiting for it to drain.
   */
  private final int QUEUE_MAX_BUFFERS = 10;

  /**
   * The number of statements per batch for performance
   * metrics results.
   */
  private static final double STATEMENT_COUNT_BATCH = 250000;

  /**
   * The JRDF (RIO) parser instance to use.
   */
  private final Parser parser;

  private InputStream inputStream;

  private Triple[] headBuffer = null;

  private int headIndex = 0;

  private Triple[] tailBuffer = null;

  private int tailIndex = 0;

  /**
   * The queue of buffers of triples generated by the RDF/XML parser.
   */
  private LinkedList queue = new LinkedList();

  /**
   * The number of statements parsed so far.
   *
   * When {@link #complete} is <code>true</code>, this will be the number of
   * statements in the RDF/XML document.
   */
  private long statementCount = 0;

  /**
   * true if statementCount is the count of the total number of statements in
   * the entire file because the parser has reached the end of the file without
   * error.
   */
  private boolean statementCountIsTotal = false;

  /**
   * Flag used to indicate that the end of the RDF/XML file has been reached.
   */
  private boolean complete = false;

  /**
   * The exception which interrupted parsing, or <code>null</code> is parsing
   * is successful.
   */
  private Throwable exception = null;

  /**
   * The base URI from which the {@link #inputStream} came and where any
   * relative URI references within the stream should be resolved to absolute
   * form.
   *
   * This field may be <code>null</code> if the origin of the stream is
   * unknown, although in that case all URI references within the stream must
   * be absolute.
   */
  private URI baseURI;

  /**
   * The initial start time for performance
   * metrics results.
   */
  private double startTime;

  /**
   * The time the last batch of statements inserted
   */
  private double lastStatementLoadTime;

  private boolean isInfoEnabled = false;


  //
  // Constructor
  //

  /**
   * Sole constructor.
   */
  ParserThread(Content content) throws NotModifiedException, TuplesException
  {
    // Validate "content" parameter
    if (content == null) {
      throw new IllegalArgumentException("Null \"content\" parameter");
    }

    // Initialize fields
    this.baseURI      = content.getURI();
    try {
      this.inputStream  = content.newInputStream();
    }
    catch (IOException e) {
      throw new TuplesException("Unable to obtain input stream from " + baseURI,
                                e);
    }

    try {
      this.parser = new RdfXmlParser(
          new GraphElementFactoryImpl(), new ParserBlankNodeFactoryImpl()
      );
    }
    catch (GraphException e) {
      throw new TuplesException("Unable to create RIO parser instance", e);
    }

    // Configure the RDF/XML parser
    parser.setParseErrorListener(this);
    parser.setStatementHandler(this);

    // is info enabled
    isInfoEnabled = logger.isInfoEnabled();

    // Used for statistics during a load
    startTime = System.currentTimeMillis();
    lastStatementLoadTime = startTime;
  }

  /**
   * @return the number of statements parsed so far
   */
  synchronized long getStatementCount() throws TuplesException
  { 
    checkForException();
    return statementCount;
  }

  /**
   * @return the total number of statements in the file
   */
  synchronized long waitForStatementTotal() throws TuplesException
  { 
    while (!complete) {
      checkForException();

      // Keep the LinkedList drained.
      queue.clear();
      notifyAll();

      try {
        wait();
      } catch (InterruptedException ex) {
        throw new TuplesException("Abort");
      }
    }
    checkForException();
    assert statementCountIsTotal;
    return statementCount;
  }

  /**
   * Returns true if getStatementCount() would return the total number
   * of statements in the file.
   */
  synchronized boolean isStatementCountTotal() throws TuplesException
  {
    checkForException();
    return statementCountIsTotal;
  }

  //
  // Method implementing Runnable
  //

  public void run()
  {
    Throwable t = null;

    try {
      parser.parse(inputStream, baseURI.toString());
      if (logger.isDebugEnabled()) {
        logger.debug("Parsed RDF/XML");
      }
      return;
    } catch (Throwable th) {
      t = th;
    } finally {
      flushQueue(t);
    }

    if (logger.isDebugEnabled()) {
      logger.debug("Exception while parsing RDF/XML", exception);
    }
  }

  //
  // Methods implementing StatementHandler
  //

  public void handleStatement(SubjectNode   subject,
                              PredicateNode predicate,
                              ObjectNode    object)
    throws StatementHandlerException
  {
    if (logger.isDebugEnabled()) {
      logger.debug("Parsed " + subject + " " + predicate + " " + object +
                   " from " + baseURI);
    }

    // Buffer the statement
    addTriple(new TripleImpl(subject, predicate, object));
  }

  //
  // Methods implementing ErrorHandler
  //

  /**
   * Recoverable error.
   *
   * @param message  explanatory text
   * @param line  line number where the error occurred
   * @param column  column number where the error occurred
   */
  public synchronized void error(String message, int line, int column)
  {
    exception = saxParseException(message, line, column);
    logger.error(
      "Error, " + line + ", column " + column + ": " + message, exception
    );
  }

  /**
   * Non-recoverable error.
   *
   * @param message  explanatory text
   * @param line  line number where the fatal error occurred
   * @param column  column number where the fatal error occurred
   */
  public synchronized void fatalError(String message, int line, int column)
  {
    exception = saxParseException(message, line, column);
    logger.error(
      "Fatal error, line " + line + ", column " + column + ": " + message,
      exception
    );
  }

  /**
   * Warning.
   *
   * @param message  explanatory text
   * @param line  line number where the warning condition occurred
   * @param column  column number where the warning condition occurred
   */
  public void warning(String message, int line, int column)
  {
    logger.warn(
      "Warning, line " + line + ", column " + column + ": " + message
    );
  }

  //
  // Internal methods
  //

  private SAXParseException saxParseException(String message,
                                              int    line,
                                              int    column)
  {
    LocatorImpl locatorImpl = new LocatorImpl();
    locatorImpl.setLineNumber(line);
    locatorImpl.setColumnNumber(line);

    return new SAXParseException(message, locatorImpl);
  }

  /**
   * If an exception occurred in the parser, throws a TuplesException that
   * wraps the exception.
   */
  private void checkForException() throws TuplesException
  {
    if (exception != null) {
      queue.clear();
      headIndex = 0;
      headBuffer = null;
      throw new TuplesException("Exception while reading " + baseURI,
                                exception);
    }
  }

  /**
   * Returns a new triple from the queue or null if there are no more triples.
   */
  Triple getTriple() throws TuplesException
  {
    if (headBuffer == null || headIndex >= headBuffer.length) {
      // Get another buffer from the queue.
      headIndex = 0;
      headBuffer = null;
      headBuffer = getBufferFromQueue();
      if (headBuffer == null) {
        // No more triples.
        return null;
      }
      assert headBuffer.length > 0;
    }

    // Get a triple from the headBuffer.
    Triple triple = headBuffer[headIndex];
    headBuffer[headIndex++] = null;
    assert triple != null;
    return triple;
  }

  private synchronized Triple[] getBufferFromQueue() throws TuplesException
  {
    while (queue.isEmpty()) {
      checkForException();
      if (complete) {
        // No more buffers in the queue.
        return null;
      }

      // Wait for a buffer.
      try {
        wait();
      } catch (InterruptedException ex) {
        throw new TuplesException("Abort");
      }
    }
    checkForException();

    notifyAll();
    return (Triple[]) queue.removeFirst();
  }

  private void addTriple(Triple triple) {
    assert triple != null;
    if (tailBuffer == null) {
      tailBuffer = new Triple[BUFFER_SIZE];
      tailIndex = 0;
    }
    tailBuffer[tailIndex++] = triple;

    if (tailIndex >= tailBuffer.length) {
      // Add the buffer to the queue.
      addBufferToQueue(tailBuffer);
      tailBuffer = null;
      tailIndex = 0;
      logStatementActivity();
    }
  }

  private synchronized void flushQueue(Throwable t) {
    if (interrupted()) {
      if (t == null) {
        t = new InterruptedException();
      }
    }

    if (t != null) {
      exception = t;
      queue.clear();
    } else if (exception == null) {
      // End of file has been reached without error.
      if (tailBuffer != null) {
        // There is at least one triple in the tailBuffer.
        assert tailIndex > 0;
        Triple[] buf = new Triple[tailIndex];
        System.arraycopy(tailBuffer, 0, buf, 0, tailIndex);
        addBufferToQueue(buf);
        logStatementActivity();
      }
      statementCountIsTotal = true;
    } else {
      // An exception has already been reported.
      queue.clear();
    }
    tailBuffer = null;
    tailIndex = 0;
    complete = true;
    notifyAll();
  }

  private synchronized void addBufferToQueue(Triple[] buffer)
  {
    assert buffer != null;
    // Wait for the queue to drain a bit if it's too full
    while (queue.size() >= QUEUE_MAX_BUFFERS) {
      try {
        wait();
      } catch (InterruptedException ex) {
        throw new RuntimeException("Abort");
      }
    }
    queue.addLast(buffer);
    statementCount += buffer.length;
    notifyAll();
  }

  /**
   * Stops the thread.
   */
  synchronized void abort()
  {
    interrupt();

    // Clear the triples list and notify in case ARP uses an internal thread
    // which has become blocked on the list being MAX_TRIPLES in size.
    queue.clear();
    notifyAll();
  }

  private void logStatementActivity()
  {
    // For very large documents, periodically log activity.
    if (isInfoEnabled) {
      if (statementCount % STATEMENT_COUNT_BATCH == 0) {
        long now = System.currentTimeMillis();
        logger.info("\tbatch timestamp\t" + now +
          "\tstatements\t" + statementCount +
          "\tper second\t" + Math.round((STATEMENT_COUNT_BATCH /
          (now - lastStatementLoadTime))*1000) +
          "\tavg per seconds\t" + Math.round((statementCount /
          (now - startTime))*1000));

        // update the current time for performance logging
        lastStatementLoadTime = now;
      }
    }
  }

}
