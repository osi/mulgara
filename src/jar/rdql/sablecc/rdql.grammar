Package org.mulgara.rdql;

/*
 * RDQL (SableCC grammar)
 */

Helpers
  digit          = ['0'..'9'];
  utf8_character = [0..0xFFFD];
  ws             = 9 | 10 | 13 | 32 | 160;

  /* As defined in XML Namespace v1.1 and XML 1.1, except no colon */
  name_start_char = ['A'..'Z'] | '_' | ['a'..'z'] | [0xC0..0xD6] |
                    [0xD8..0xF6] | [0xF8..0x2FF] | [0x370..0x37D] |
                    [0x37F..0x1FFF] | [0x200C..0x200D] | [0x2070..0x218F] |
                    [0x2C00..0x2FEF] | [0x3001..0xD7FF] | [0xF900..0xFDCF] |
                    [0xFDF0..0xFFFD];
  name_char       = name_start_char | '-' | '.' | ['0'..'9'] | 0xB7 |
                    [0x300-0x36F] | [0x203F..0x2040];

  /* As defined in RFC 2396 */
  mark                     = '-' | '_' | '.' | '!' | '~' | '*' | 39 | '(' | ')';
  unreserved_uri_character = ['A'..'Z'] | ['a'..'z'] | ['0'..'9'] | mark;
  reserved_uri_character   = ';' | '/' | '?' | ':' | '@'
                           | '&' | '=' | '+' | '$' | ',';
  hex                      = digit | ['a'..'f'] | ['A'..'F'];

States
  def, uri;  /* default state */

Tokens
  {def} quit       = 'QUIT';
  {def} select     = 'SELECT';           /* Case Insensitive match */
  {def} source     = 'FROM' | 'SOURCE';  /* Case Insensitive match */
  {def} where      = 'WHERE';            /* Case Insensitive match */
  {def} and        = 'AND';              /* Case Insensitive match */
  {def} prefixes   = 'USING';            /* Case Insensitive match */
  {def} for        = 'FOR';              /* Case Insensitive match */
  {def} comma      = ',';
  {def} lparen     = '(';
  {def} rparen     = ')';
  {def} dot        = '.';
  {uri->def} gt    = '>';
  {def->uri} lt    = '<';
  {def} negation   = '!' | '~';
  {def} hook       = '?';
  {def} colon      = ':';
  {def} eq         = '==';
  {def} neq        = '!=';
  {def} le         = '<=';
  {def} ge         = '>=';
  {def} sc_or      = '||';
  {def} sc_and     = '&&';
  {def} str_eq     = 'EQ' | 'eq';  /* Case Insensitive match */
  {def} str_ne     = 'NE';  /* Case Insensitive match */
  {def} plus       = '+';
  {def} minus      = '-';
  {def} star       = '*';
  {def} slash      = '/' ws;  // Whitespace distinguishies this from a comment
  {def} rem        = '%';
  {def} str_match  = '=~' | '~~';
  {def} str_nmatch = '!~';
  {def} datatype   = '^^';
  {def} at         = '@';
  {def} true       = 'TRUE';   /* Case insensitive match */
  {def} false      = 'FALSE';  /* Case insensitive match */
  {def} null       = 'NULL';   /* Case insensitive match */

  {def} ncname     = name_start_char name_char*;  /* no colons allowed */
  {def} integer_literal        = digit+;
  {def} floating_point_literal = digit* '.' digit+ ('e' ('+' | '-')? digit+)?;
  {def} string_literal1        = '"' [utf8_character - '"']* '"';
  {def} string_literal2        = 39 [utf8_character - 39]* 39;
  {def} pattern_literal        = '/' ('p' | 'r') [utf8_character - '/']* '/';
  {uri} unquoted_uri = (unreserved_uri_character | reserved_uri_character | '#' | ('%' hex hex))*;

  {def} c_comment   = '/*' utf8_character* '*/';
  {def} cpp_comment = '//' [utf8_character - 13]* 13;
  {def, uri->def} whitespace  = ws+;

  {def} terminator = ';';

Ignored Tokens
  c_comment, cpp_comment, whitespace;

Productions

  compilation_unit = command?;

  command = {query} query
          | {quit}  quit;

  comma_opt = comma?;

  query = select_clause source_clause? triple_pattern_clause constraint_clause? prefixes_clause?;

  select_clause = {some} select var select_tail*
                | {all}  select star;

  select_tail = comma_opt var;

  source_clause = source source_selector source_tail*;

  source_tail = comma_opt source_selector;

  source_selector = uri;

  triple_pattern_clause = where triple_pattern triple_tail*;

  triple_tail = comma_opt triple_pattern;

  triple_pattern =
    lparen [subject]:var_or_uri [first]:comma_opt [predicate]:var_or_uri [second]:comma_opt [object]:var_or_const rparen;

  constraint_clause = and expression constraint_tail*;

  constraint_tail = {comma} comma expression
                  | {and}   and expression;

  var_or_uri = {variable} var
             | {uri}      uri;

  var_or_const = {variable} var
               | {constant} const;

  var = hook identifier;

  prefixes_clause = prefixes prefix_decl prefixes_clause_tail*;

  prefixes_clause_tail = comma? prefix_decl;

  prefix_decl = identifier for quoted_uri;

  expression = conditional_or_expression;

  conditional_or_expression = conditional_and_expression conditional_or_tail*;

  conditional_or_tail = sc_or conditional_and_expression;

  conditional_and_expression = string_equality_expression conditional_and_tail*;

  conditional_and_tail = sc_and string_equality_expression;

  string_equality_expression = arithmetic_condition string_equality_tail*;

  string_equality_tail = {equal}     str_eq arithmetic_condition
                       | {not_equal} str_ne arithmetic_condition
                       | {match}     str_match pattern_literal
                       | {not_match} str_nmatch pattern_literal;

  arithmetic_condition = equality_expression;

  equality_expression = relational_expression equality_tail?;

  equality_tail = {equal}     eq relational_expression
                | {not_equal} neq relational_expression;

  relational_expression = additive_expression relational_tail?;

  relational_tail = {lt} lt additive_expression
                  | {gt} gt additive_expression
                  | {le} le additive_expression
                  | {ge} ge additive_expression;

  additive_expression = multiplicative_expression additive_tail*;

  additive_tail = {plus}  plus multiplicative_expression
                | {minus} minus multiplicative_expression;

  multiplicative_expression = unary_expression multiplicative_tail*;

  multiplicative_tail = {multiply} star unary_expression
                      | {divide}   slash unary_expression
                      | {modulus}  rem unary_expression;

  unary_expression = {unsigned} unary_expression_not_plus_minus 
                   | {plus}     plus unary_expression
                   | {minus}    minus unary_expression;

  unary_expression_not_plus_minus = {negation} negation unary_expression
                                  | {primary} primary_expression;

  primary_expression = {variable}      var
                     | {const}         const
                     | {subexpression} lparen expression rparen;

  const = {uri}     uri
        | {number}  numeric_literal
        | {text}    text_literal
        | {boolean} boolean_literal
        | {null}    null_literal;

  numeric_literal = {integer}        integer_literal
                  | {floating_point} floating_point_literal;

  text_literal = lexical_form_clause at_clause? datatype_clause?;

  lexical_form_clause = {form1} string_literal1
                      | {form2} string_literal2;

  at_clause = at ncname;
  
  datatype_clause = datatype uri;

  boolean_literal = {true}  true
                  | {false} false;

  null_literal = null;

  uri = {uri}   quoted_uri
      | {qname} qname;

  quoted_uri = lt unquoted_uri gt;

  /* Unlike XML Namespaces, the local part is optional */
  qname = [ns_prefix]:ncname colon [local_part]:ncname;

  identifier = {ncname}   ncname
             | {select}   select
             | {source}   source
             | {where}    where
             | {prefixes} prefixes
             | {for}      for
             | {stq_eq}   str_eq
             | {str_ne}   str_ne ;
